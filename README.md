# HC Database (HydraChain Database)

Последнее изменение: 12.12.2025 04:15

## Обзор

HC Database (HydraChain Database) - это встраиваемая система управления базами данных, разработанная специально для экосистемы HydraChain. Она обеспечивает высокую производительность при записи и чтении данных, а также поддерживает сложные агрегационные операции для учета движений и итогов.

## Особенности

- Высокая производительность при записи и чтении данных
- Поддержка транзакций
- Автоматическое вычисление итоговых значений
- Оптимизация запросов с помощью индексации
- Встраиваемая архитектура с минимальными требованиями к ресурсам

## Архитектурные компоненты

### 1. Ядро СУБД (Database Core)

- Управление соединениями с базой данных
- Механизмы транзакций с поддержкой ACID
- Контроль параллелизма и конкурентного доступа
- Управление памятью и кэшированием
- Логирование операций

### 2. Менеджер таблиц (Table Manager)

- Создание, модификация и удаление таблиц
- Определение схем данных и метаданных
- Управление индексами
- Валидация данных при вставке

### 3. Движения (Movement Engine)

- Логирование движений при обработке блоков
- Управление временной последовательностью записей
- Интеграция с блокчейном
- Обработка транзакций

### 4. Агрегации (Aggregation Engine)

- Автоматическое вычисление итоговых значений
- Поддержка различных типов агрегаций
- Синхронизация с таблицей движений
- Кэширование результатов

### 5. Индексация (Indexing Engine)

- Создание и управление индексами
- Оптимизация запросов
- Поддержка сложных запросов
- Управление производительностью

### 6. Интерфейс запросов (Query Interface)

- API для работы с данными
- Обработка запросов
- Формирование результатов
- Управление сессиями

## Структура данных

### Создание Базы данных

При создании базы разработчик определяет:

- Название базы
- Тип базы (остатки/обороты/универсальная)
- Список измерений (определяются разработчиком)
- Список ресурсов (определяются разработчиком)
- Настройки агрегации

### Таблицы движений (Movements)

- `movement_id`: Уникальный идентификатор движения (UUID)
- `timestamp`: Дата и время операции (DateTime)
- `block_id`: Идентификатор блока (String)
- `transaction_id`: Идентификатор транзакции (String)
- `measurements`: Измерения (определяются разработчиком)
- `resources`: Ресурсы (определяются разработчиком)
- `direction`: Направление движения (enum: income/expense)

#### Вставка движений

Для вставки движений используется метод `insertMovement()` класса `MovementTable`. Пример:

```dart
import 'package:hc_db/hc_db.dart';

// Создание базы данных
final db = await Database.createDatabase(
  directoryPath: './my_database',
  databaseName: 'my_accounting_db',
  tableType: TableType.balance,
  measurements: ['product', 'region'],
  resources: ['quantity', 'amount'],
);

// Получение схемы таблицы
final tableSchema = db.getTableSchema('my_accounting_db');

// Создание таблицы движений
final movementTable = MovementTable(db, tableSchema);

// Создание движения
final movement = Movement(
  movementId: 'M001',
  timestamp: DateTime.now(),
  blockId: 'B001',
  transactionId: 'T001',
  measurements: {
    'product': 'Product A',
    'region': 'Region 1',
  },
  resources: {
    'quantity': BigInt.from(100),
    'amount': BigInt.from(1000),
  },
  direction: Direction.income,
);

// Вставка движения
await movementTable.insertMovement(movement);
```

#### Получение движений

Для получения движений используется метод `getMovements()` класса `MovementTable`, который позволяет фильтровать данные по различным критериям:

```dart
// Получение всех движений
List<Movement> allMovements = await movementTable.getMovements();

// Получение движений с фильтрацией по измерениям
List<Movement> filteredMovements = await movementTable.getMovements(
  measurementsFilter: {
    'product': 'Product A',
    'region': 'Region 1',
  },
);

// Получение движений с фильтрацией по времени
List<Movement> timeFilteredMovements = await movementTable.getMovements(
  fromTime: DateTime(2023, 1),
  toTime: DateTime(2023, 12, 31),
);

// Ограничение количества возвращаемых движений
List<Movement> limitedMovements = await movementTable.getMovements(
  limit: 100,
);

// Комбинированный фильтр
List<Movement> combinedFilteredMovements = await movementTable.getMovements(
  measurementsFilter: {
    'product': 'Product A',
  },
  fromTime: DateTime(2023, 1, 1),
  toTime: DateTime(2023, 12, 31),
  limit: 50,
);
```

### Таблицы итогов (Aggregations)

- `aggregation_id`: Уникальный идентификатор агрегации (UUID)
- `measurements`: Измерения (определяются разработчиком)
- `resources`: Ресурсы (определяются разработчиком)
- `current_value`: Текущее значение (BigInt)
- `last_updated`: Дата последнего обновления (DateTime)
- `version`: Версия данных (int)

### Таблицы оборотов (Turnovers)

- `turnover_id`: Уникальный идентификатор оборота (UUID)
- `timestamp`: Временная метка периода (DateTime)
- `period_type`: Тип периода (enum: year, month, day, hour, minute, second)
- `measurements`: Измерения (определяются разработчиком)
- `resources`: Ресурсы (определяются разработчиком)
- `turnover_value`: Значение оборота (BigInt)
- `count`: Количество операций (int)
- `last_updated`: Дата последнего обновления (DateTime)

## Принципы работы

### Запись данных

При добавлении нового блока:

1. Создаются записи в таблице движений
2. Автоматически обновляется таблица итогов
3. Обновляются соответствующие индексы
4. Все операции выполняются в рамках транзакции

### Чтение данных

При запросе данных система:

1. Определяет тип запроса (итоги, обороты или движение)
2. Для итоговых запросов использует таблицу итогов для получения актуальных значений
3. Для агрегированных запросов также использует данные из таблицы оборотов
4. Обеспечивает согласованность данных между всеми источниками
5. Оптимизирует запросы с помощью индексов

### Агрегация данных

Система автоматически поддерживает:

- Итоговые значения для каждого измерения
- Обороты за периоды (секунда, минута, час, день, месяц, год)
- Сложные агрегационные функции
- Консистентность между движением и итогами

## Технические характеристики

### Производительность

- Высокая скорость записи (до 100 000 записей/сек)
- Высокая скорость чтения (миллисекунды для простых запросов)
- Параллельная обработка запросов
- Минимальные задержки при обработке транзакций

### Надежность

- Поддержка ACID транзакций
- Контроль целостности данных
- Репликация данных
- Система восстановления после сбоев

## Структура проекта

```
hc_db/
├── lib/
│   ├── core/
│   │   ├── database.dart
│   │   ├── transaction.dart
│   │   └── cache.dart
│   ├── tables/
│   │   ├── table_manager.dart
│   │   ├── movement_table.dart
│   │   ├── aggregation_table.dart
│   │   └── turnover_table.dart
│   ├── engines/
│   │   ├── movement_engine.dart
│   │   ├── aggregation_engine.dart
│   │   └── indexing_engine.dart
│   ├── queries/
│   │   ├── query_interface.dart
│   │   └── query_parser.dart
│   ├── utils/
│   │   ├── helpers.dart
│   │   └── validators.dart
│   └── main.dart
├── test/
│   └── hc_db_test.dart
└── pubspec.yaml
```

## Примеры использования

### Создание базы данных

```dart
import 'package:hc_db/hc_db.dart';

// Создание базы данных
final db = await Database.createDatabase(
 directoryPath: './my_database',
  databaseName: 'my_accounting_db',
  tableType: TableType.balance,
  measurements: ['wallet_address', 'user_id'],
  resources: ['amount', 'points'],
);
```

### Открытие существующей базы данных

Метод `Database.open()` позволяет открыть уже существующую базу данных. По указанному пути `directoryPath` должна находиться папка, содержащая подпапку с названием базы данных и соответствующими файлами базы данных.

```dart
import 'package:hc_db/hc_db.dart';

// Открытие существующей базы данных
final db = await Database.open(
  directoryPath: './my_database',
  databaseName: 'my_accounting_db',
);
```

При открытии базы данных система автоматически:

- Проверяет существование базы данных по указанному пути
- Считывает конфигурационный файл для восстановления параметров базы данных
- Восстанавливает тип таблицы, измерения и ресурсы из конфигурации
- Инициализирует все необходимые компоненты базы данных

#### Правила именования базы данных

Название базы данных должно:

- Не быть пустым
- Начинаться с буквы (латинская буква)
- Содержать только латинские буквы, цифры, символы '-' и '_'

Примеры допустимых имен:

- `my_accounting_db`
- `accounting-2025`
- `Test123`
- `a` (минимально допустимое имя)

Примеры недопустимых имен:

- `123my_db` (начинается с цифры)
- `my@db` (содержит недопустимый символ '@')
- `-my_db` (начинается с недопустимого символа '-')
- `` (пустое имя)

#### Правила именования измерений и ресурсов

Названия измерений и ресурсов должны:

- Не быть пустыми
- Начинаться с буквы (латинская буква)
- Содержать только латинские буквы, цифры, символы '-' и '_'

Примеры допустимых имен:

- `wallet_address`
- `user_id`
- `amount`
- `points`
- `A1`
- `test-field`

Примеры недопустимых имен:

- `123field` (начинается с цифры)
- `field@name` (содержит недопустимый символ '@')
- `-field` (начинается с недопустимого символа '-')
- `_field` (начинается с символа '_', который не разрешен)
- `` (пустое имя)

## План разработки

### Этап 1: Подготовительный этап

**Цель:** Подготовка рабочей среды и анализ требований

[l] Настройка окружения разработки
[l] Анализ требований к производительности
[l] Определение архитектурных ограничений
[l] Подготовка документации
[l] Создание базовой структуры проекта

### Этап 2: Ядро СУБД

**Цель:** Реализация основных компонентов ядра СУБД

[] Реализация управления соединениями
[] Механизмы транзакций с поддержкой ACID
[] Управление памятью и кэшированием
[] Логирование операций
[] Тестирование ядра СУБД

### Этап 3: Таблицы и движение

**Цель:** Реализация системы таблиц и движений

[] Менеджер таблиц
[] Создание и управление таблицами
[] Логирование движений
[] Управление временной последовательностью
[] Интеграция с блокчейном
[] Обработка транзакций
[] Индексация данных

### Этап 4: Агрегации и итоги

**Цель:** Реализация механизмов агрегации и итогов

[] Агрегационный движок
[] Таблицы итогов
[] Таблицы оборотов
[] Пересчет данных
[] Система версионирования
[] Тестирование агрегаций

### Этап 5: Интерфейс и оптимизация

**Цель:** Реализация интерфейсов и оптимизация производительности

[] API для работы с данными
[] Оптимизация производительности
[] Поддержка различных форматов ответов
[] Механизмы авторизации и аутентификации
[] Тестирование производительности

### Этап 6: Тестирование и документация

**Цель:** Полное тестирование и документирование

[] Модульное тестирование
[] Интеграционное тестирование
[] Тестирование производительности
[] Полная документация
[] Документация по API
[] Готовность к выпуску

## Риски и ограничения

### Технические риски

- Сложности с достижением требуемой производительности
- Проблемы с масштабируемостью
- Сложности с интеграцией с блокчейном

### Временные риски

- Задержки в реализации отдельных компонентов
- Необходимость пересмотра архитектуры
- Проблемы с тестированием

## Критерии успеха

1. Соответствие требованиям производительности
2. Стабильная работа в условиях высокой нагрузки
3. Полная документация
4. Полнота тестового покрытия
5. Простота интеграции в существующие системы

## Мониторинг и контроль

### Ключевые показатели

- Скорость выполнения операций
- Уровень покрытия тестами
- Время отклика системы
- Уровень стабильности

### Отчетность

- Еженедельные отчеты о прогрессе
- Мониторинг производительности
- Анализ рисков
- Отчеты о тестировании

## Установка и запуск

Для использования библиотеки необходимо:

1. Добавить зависимость в pubspec.yaml:

```yaml
dependencies:
  hc_db: ^1.0.0
```

2. Импортировать библиотеку в ваш проект:

```dart
import 'package:hc_db/hc_db.dart';
```

3. Инициализировать базу данных:

```dart
final db = Database();
await db.init();
```

## Файловая структура базы данных

HC Database создает следующую структуру файлов для каждой базы данных:

- `{databaseName}.config` - файл конфигурации базы данных
- `{databaseName}.movements` - файл для хранения таблицы движений
- `{databaseName}.aggregations` - файл для хранения таблицы агрегаций (итогов)
- `{databaseName}.turnovers` - файл для хранения таблицы оборотов (при необходимости)

### Пример файла конфигурации

При создании базы данных генерируется JSON-файл конфигурации, содержащий основные параметры:

```json
{
 "databaseName": "my_accounting_db",
 "tableType": "balance",
  "measurements": ["wallet_address", "user_id"],
  "resources": ["amount", "points"],
  "createdAt": "2025-12-10T18:35:00.000Z",
  "pageSize": 4096,
  "extentSize": 6536,
  "minReserveExtents": 10
}
```

Параметры конфигурации:

- `databaseName` - название базы данных
- `tableType` - тип таблицы (balance, turnover, universal)
- `measurements` - список измерений
- `resources` - список ресурсов
- `createdAt` - дата создания базы данных
- `pageSize` - размер страницы в байтах
- `extentSize` - размер экстента в байтах
- `minReserveExtents` - минимальное количество зарезервированных экстентов

## Логирование

HC Database поддерживает полноценное логирование в файл с возможностью настройки через конфигурационный файл.

### Настройки логирования

В конфигурационном файле базы данных можно указать следующие параметры логирования:

```json
{
  "logging": {
    "level": "INFO",
    "filePath": "./logs/database.log",
    "maxFileSize": 10485760,
    "maxFilesCount": 5
  }
}
```

Где:
- `level` - уровень логирования (ALL, FINEST, FINER, FINE, CONFIG, INFO, WARNING, SEVERE, SHOUT, OFF)
- `filePath` - путь к файлу лога (если не указан, логирование будет только в консоль)
- `maxFileSize` - максимальный размер файла лога в байтах (по умолчанию 10MB)
- `maxFilesCount` - максимальное количество файлов при ротации (по умолчанию 5)

### Пример использования

При создании или открытии базы данных настройки логирования будут автоматически загружены из конфигурационного файла:

```dart
// Создание базы данных с настройками логирования
final database = await Database.createDatabase(
  directoryPath: './db',
  databaseName: 'my_database',
  tableType: TableType.balance,
  measurements: ['measurement1', 'measurement2'],
  resources: ['resource1', 'resource2'],
);

// Открытие существующей базы данных
final database = await Database.open(
  directoryPath: './db',
  databaseName: 'my_database',
);
```

Логи будут записываться в указанный файл с автоматической ротацией при достижении максимального размера.

## Документация

Для получения более подробной информации о каждом компоненте системы обратитесь к документации в директории docs/ или к исходным кодам проекта.
